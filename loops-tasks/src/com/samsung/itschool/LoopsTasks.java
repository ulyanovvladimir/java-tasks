package com.samsung.itschool;

public class LoopsTasks {

    public static void main(String[] args) {
        // выводим числа Фибоначи
        System.out.println(factorial(5));

        int i = lastEnemy(new int[]{3, 5, 2});
        System.out.println(i);

        System.out.println(lastEnemy(new int[]{-1, 1, 0, 1, -1}));

    }


    /**
     * Евклидово расстояние между точками n-мерного пространства
     *
     * @param x точка n-мерного пространства
     * @param y точка n-мерного пространства
     * @return расстояние между точками
     * @link http://statistica.ru/glossary/general/evklidovo-rasstoyanie/
     */
    public static double dist(double[] x, double[] y) {
        //todo Определить стартовое значение аккумулятора
        double sum;
        //todo в цикле суммировать в аккумуляторе квадраты разностей координат.


        //todo вернуть квадратный корень накопленной суммы
        return 0;
    }


    /**
     * Числа Фибоначи.
     * Числами Фибоначи называют следующий ряд:
     * 1 1 2 3 5 8 13 21 34 ...
     * Первые два элемента последовательности равняются 1.
     * Последующие элементы вычисляются с помощью суммы двух предыдущих элементов:
     * 1+1 = 2
     * 1+2 = 3
     * 2 + 3 = 5
     * и т.д.
     * <p>
     * Функция возвращает массив, заполненный числами Фибоначи размерности n
     *
     * @param n первых чисел ряда Фибоначи
     * @return массив, содержащий n первых чисел ряда Фибоначи
     */
    public static int[] fibonachi(int n) {
        //todo Определяем массив размерности n
        int[] mas;
        //todo первые два элемента равны 1.

        //todo с третьего элемента число Фибоначи равно сумме двух предыдущих

        //todo Возвращаем массив mas
        return new int[1];
    }

    /**
     * Значение многочлена функции
     * f(x) = a0*x^(n-1) + a1*x^(n-2)+ ... + an
     *
     * @param a - вектор параметров
     * @param x - значение аргумента фукнции
     * @return значение f(x)
     */
    public static double f(double a[], double x) {

        //todo заводим аккумулятор для суммы
        double sum;
        //todo находим n как длину массива параметров (переменная "a")
        int n;
        //todo в цикле суммируем по формуле

        //todo возвращаем накопленную сумму
        return 0;
    }

    /**
     * Найти первый корень уравнения на интервалле от min до max c шагом step
     * В случае, если корней нет, возвращаем Double.MAX_VALUE
     *
     * @param a - вектор параметров, задающий многочлен
     * @param min - минимальное значение x, левая граница отрезка
     * @param max - максимальное значение x, правая граница отрезка
     * @param step - шаг, на который мы изменяем x во время перебора
     * @return первый корень уравнения f(x) = 0 в интервале от min до max
     */
    public static double equation(double a[], double min, double max, double step) {
        //todo организовать цикл от min до max с шагом step
        //todo для каждого x вычисляем значение функции f(x)
        //todo проверяем, что |f(x)| ~ 0

        //ПОДСКАЗКА: для вычисления значения f(x) можно испольовать вызов функции f(a,x), например для x = 1.5:
        // double fx = f(a, 1.5);

        //если на заданном интервале не нашли корней, возвращаем константу Double.MAX_VALUE
        return Double.MAX_VALUE;
    }

    /**
     * Функция возвращает факториал числа
     * @param n - число от которого берется факториал
     * @return факториал числа n
     *
     */
    public static long factorial(int n){
        //todo реализовать с помощью цикла
        // ПОДСКАЗКА: попробуйте использовать цикл с аккумулятором, по аналогии со суммой чисел.

        return -1;
    }

    /**
     * Космический рейнджер
     * @link http://www.russiancodecup.ru/ru/tasks/round/57/A/
     *
     * Нужно найти индекс элемента массива,
     * значение которого равняется сумме всех остальных элементов массива.
     *
     * @param f - массив сил врагов
     * @return индекс врага с силой равной суммарной силе всех остальных врагов
     */
    public static int lastEnemy(int[] f){
        //todo
        return 0;
    }

    /**
     * Реверс массива. Возвращает массив из элементов, расположенных в обратном порядке.
     * @param arr исходный массив
     * @return массив элементов, расположенных в обратном порядке
     */
    public static int[] reverse(int[] arr){
        //todo
        return arr;
    }
}
