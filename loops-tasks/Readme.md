# С чего начать
Откройте проект в IntelliJ Idea с помощью пункта "Open" в главном меню и укажите в качестве корня проекта папку loops-tasks.

# Тестирование
В качестве тестов используется библиотека JUnit. Если вы используете проект Idea, то она у вас будет подключена автоматически. Если же вы используете другую IDE, то вам необходимо подключить JUnit самостоятельно. Рекомендуемая версия библиотеки не ниже 4. 

> В Idea для того чтобы подключить библиотеку JUnit вам необходимо встать курсором на любую красную строчку с @Test и нажать ALT+ENTER. Затем выбрать "add JUnit to classpath".

Для запуска тестов нажмите правой кнопкой на класс Tests и в выпадающем меню выберите  Run 'Tests'

# Памятка по массивам
```java
//объявляем целочисленный массив mas
int[] mas;
//объявляем массив вещественных чисел размерности 5
double[] arr = new double[5];
//создаем массив discounts, состоящий из фиксированных значений, разделенных запятыми
float[] discounts = new float[]{0.1, 0.25, 0.5};
//динамически определяем размерность n массива nums, вводя его с консоли.
int n = scanner.nextInt();
int[] nums = new int[n];

//Запись в первый элемент массива arr (нумерация с нуля)
arr[0] = 1;
//Запись в массив arr с индексом i
arr[i] = 5;

//Чтение из массива arr второго элемента с индексом 1
int second = arr[1];

//Получение размерности массива arr с помощью поля length
int n = arr.length;
```

# Памятка по циклу for
```java
// сумма первых N натуральных чисел
// заводим и инициализируем переменную-аккумулятор с именем sum, присваиваем ей значение 0.
int sum = 0;
//в цикле по i от 1 до n пробегаем
for (int i = 1; i <= n; i++){
    //для каждого i производим прибавление i к sum. Сумма при этом изменяется
    sum = sum + i;
}
// в результате sum содержит накопленную сумму натуральных чисел.

// ------------------------------------------------------------------

//Поиск первого отрицательного числа в массиве
int index = -1;
for (int i = 0; i < mas.length; i++){
    //для каждого i берем i-ый элемент массива и проверяем, является ли он отрицательным. 
    if(mas[i]< 0){
        index = i; //найденный индекс отрицательного элемента присваиваем переменной index
        break; // прекращаем выполнение цикла
    }
}
// в результате index содержит индекс первого найденного отрицательного числа, либо -1, если в массиве нет таких чисел.
```


# Задания

## Ряд фибоначи

Рядом Фибоначи называют следующую последовательность:

1, 1, 2, 3, 5, 8, 13, 21, 34,...

Первые два числа ряда равняются единице. Каждое последующее число является суммой двух предыдущих чисел.

Вам необходимо реализовать функцию 
```java
public static int[] fibonachi(int n) {
   //todo ...
}
```

Функция fibonachi возвращает массив, заполненный числами Фибоначи размерности n. Например, для n равного 5 должен вернуть следующий массив:
```java
{1, 1, 2, 3, 5, 8}
```

> Учтите случай, когда n равен 1
    
## Евклидово расстояние в n-мерном пространстве

Евклидово расстояние рассчитывается как корень квадратный суммы квадратов разностей координат. В общем случае, для n-мерного пространства формула следующая

![Евклидово расстояние](http://statistica.ru/upload/medialibrary/2df/image001.png)

Вам необходимо реализовать функцию 
```java
public static double dist(double[] x, double[] y) {
     //todo
}
```
Данная функция принимает на вход две точки n-мерного пространства в виде массивов x и y.
> Ничего вводить с клавиатуры не требуется. Для получения размерности используйте length для массива. Например чтобы определить количество элементов в массиве arr можно написать следующий код: 
> arr.length
> Для получения квадратного корня используйте метод Math.sqrt(double)

## Вычисление полинома
В данной задаче вам необходимо вычислить значение функции y = f(x), где

![Полином](http://latex2png.com/output//latex_1829b7ecab4f96be4147e12e290ab93d.png)

Для этого необходимо реализовать функцию-метод
```java
    public static double f(double a[], double x) {
       //todo
    }
```
Данная функция принимает в качестве параметров массив a[] и число x. Массив a задает полином. Необходимо с помощью цикла реализовать вычисление суммы элементов многочлена.

> массив a[] приходит уже заполненный и для получения его размера, возможно, потребуется использовать поле length

## Поиск корней функции
Поиском корней функции называется задача вычисления таких x, для которых f(x) = 0.

Вам необходимо реализовать функцию 
```java
    public static double equation(double a[], double min, double max, double step) {  
      //todo
    }
```
Эта функция пробегает от минимального значения min до максимального значения max с очень маленьким шагом step. Когда она находит первый попавшийся x, для которого f(x) = 0, она прекращает работу и возвращает этот найденый x, корень уравнения. Так же как и в предыдущем задании вам дан вектор параметров a[] для определении функции-полинома. 
> Для вычисления f(x) можно воспользоваться функцией, запрограммированной в предыдущем задании

```java
    // a - вектор параметров, x - конкретное значение аргумента функции f
    double fx = f(a,x);
```

Если корней на заданном отрезке нет, то функция должна вернуть значение Double.MAX_VALUE

## Реверс массива
Дан массив целых чисел. Необходимо реализовать функцию, которая возвращает массив чисел в обратном порядке.

Для этого вам необходимо реализовать функцию
```java
public static int[] reverse(int[] arr){
    //todo
    return arr;
}
```
arr - имя переменной, содержащей исходный массив. Примеры:
```
[1, 2, 3, 5] => [5, 3, 2, 1]
[4, 2, 7] => [7, 2, 4]
```

## Факториал
Необходимо запрограммировать функцию, вычисляющую факториал числа. Для этого необходимо
```java
public static long factorial(int n){
    //todo напишите свой код тут
}

```
n - число, от которого нужно взять факториал. Функция возвращает факториал числа. 
```
3 => 6
5 => 120
```


## Космический рейнджер
Для ознакомления с проблемой перейдите по ссылке:
http://www.russiancodecup.ru/ru/tasks/round/57/A/

Для решения задачи вам необходимо реализовать функцию
```java
public static int lastEnemy(int[] f){
    //todo
    return 0;
}
```
Входным параметром является массив сил врагов с именем f. На выходе необходимо найти индекс врага с силой равной силе всех остальных врагов.
Гарантируется, что такой враг имеется.

Примеры:
```java
{2, 5, 3} => 1
{-1, 1, 0, 1, -1} => 2 
```


